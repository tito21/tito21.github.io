<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href=../assets/style.css>

        <!-- Mathjax -->
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <!-- -->

        <link href="https://fonts.googleapis.com/css?family=Nunito+Sans|Nunito:300,400,700&display=swap" rel="stylesheet">
        <style>pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    background-color: #232629;
    color: #7a7c7d;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #7a7c7d;  padding-left: 4px; }
div.sourceCode
  { color: #cfcfc2; background-color: #232629; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span. { color: #cfcfc2; } /* Normal */
code span.al { color: #95da4c; background-color: #4d1f24; font-weight: bold; } /* Alert */
code span.an { color: #3f8058; } /* Annotation */
code span.at { color: #2980b9; } /* Attribute */
code span.bn { color: #f67400; } /* BaseN */
code span.bu { color: #7f8c8d; } /* BuiltIn */
code span.cf { color: #fdbc4b; font-weight: bold; } /* ControlFlow */
code span.ch { color: #3daee9; } /* Char */
code span.cn { color: #27aeae; font-weight: bold; } /* Constant */
code span.co { color: #7a7c7d; } /* Comment */
code span.cv { color: #7f8c8d; } /* CommentVar */
code span.do { color: #a43340; } /* Documentation */
code span.dt { color: #2980b9; } /* DataType */
code span.dv { color: #f67400; } /* DecVal */
code span.er { color: #da4453; text-decoration: underline; } /* Error */
code span.ex { color: #0099ff; font-weight: bold; } /* Extension */
code span.fl { color: #f67400; } /* Float */
code span.fu { color: #8e44ad; } /* Function */
code span.im { color: #27ae60; } /* Import */
code span.in { color: #c45b00; } /* Information */
code span.kw { color: #cfcfc2; font-weight: bold; } /* Keyword */
code span.op { color: #cfcfc2; } /* Operator */
code span.ot { color: #27ae60; } /* Other */
code span.pp { color: #27ae60; } /* Preprocessor */
code span.re { color: #2980b9; background-color: #153042; } /* RegionMarker */
code span.sc { color: #3daee9; } /* SpecialChar */
code span.ss { color: #da4453; } /* SpecialString */
code span.st { color: #f44f4f; } /* String */
code span.va { color: #27aeae; } /* Variable */
code span.vs { color: #da4453; } /* VerbatimString */
code span.wa { color: #da4453; } /* Warning */</style>

                <meta name="description" content="Calcular raíces cuadradas numéricamente es un problema muy antiguo. Aquí veremos como calcularlo usando un método desarrollado en mesopotamia y lo implementaremos en python.">
                <meta>
                <meta name="author" content="Alberto Di Biase">
                        <meta name="dcterms.date" content="">
                <title>Método Babilónico para calcular raíces cuadradas - Alberto Di Biase</title>


    </head>

    <body>
        <!-- Header -->
        <header>
            <h1 class="site-title">
                <a href=https://tito21.github.io/index.html>Alberto Di Biase</a>
            </h1>
            <nav>
                <ul class="nav-list">
                                            <li><a href=https://tito21.github.io/about.html>About</a></li>
                                            <li><a href=https://tito21.github.io/categories.html>Categories</a></li>
                                    </ul>
            </nav>
        </header>
        <article class="main-article">
            <h1 class="article-title">Método Babilónico para calcular raíces cuadradas</h1>
            <div class="sub-title">
                                    <span>2019-02-08 22:22:43 -0300</span>
                                <ul>
                                            <li><a href=https://tito21.github.io/categories.html#Python>Python</a></li>
                                            <li><a href=https://tito21.github.io/categories.html#algoritmo>algoritmo</a></li>
                                            <li><a href=https://tito21.github.io/categories.html#programacion>programacion</a></li>
                                    </ul>
            </div>

<h1 id="cómo-calcular-sqrt2">¿Cómo calcular <span class="math inline">\(\sqrt{2}\)</span>?</h1>
<p>¡Fácil con la app calculadora de mi celular!</p>
<p>Bien, pero sabemos que en 1600 BC mesopotamia ya se había calculado la raíz de 2 correctamente a 6 decimales. Probablemente fue calculado utilizando el algoritmo que hoy se conoce com el método Babilónico.</p>
<p>La explicación de este algoritmo puede ser deducida a partir de un <a href="https://es.wikipedia.org/wiki/C%C3%A1lculo_de_la_ra%C3%ADz_cuadrada#Algoritmo_babil%C3%B3nico">rectángulo</a> con area igual al numero que se le desea calcular el area y a través de un proceso iterativo convertirlo en un cuadrado con la misma area. Aquí deduciremos el mismo algoritmo a partir de un método numérico para encontrar los ceros de la función <span class="math inline">\(f(x)=x^2 - S\)</span> (¿puedes mostrar porque esta función?). Para encontrar numéricamente los ceros de una función existen diversos métodos, uno de los mas populares es el el método de <a href="https://es.wikipedia.org/w/index.php?title=M%C3%A9todo_de_Newton-Raphson">Newton-Raphson</a> (a veces llamado simplemente de Newton). En este articulo deduciremos la formula del método Babilónico y lo implementaremos en Python. Voy a asumir que ya tienen un conocimiento básico de las librerías <a href="https://www.numpy.org">Numpy</a> y <a href="https://www.matplotlib.org">Matplotlib</a></p>
<h2 id="metodo-de-newton-raphson">Metodo de Newton-Raphson</h2>
<p>Este método de Newton-Raphson se vasa en buscar los ceros de la función a partir de una serie de aproximaciones lineales, cada vez más cercanas al cero real.</p>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/e/e0/NewtonIteration_Ani.gif" alt="" /><figcaption>Animación del método de Newton</figcaption>
</figure>
<p>Como ya mencionamos los ceros de la función <span class="math inline">\(f(x)=x^2 - S\)</span> son <span class="math inline">\(\pm\sqrt{S}\)</span> por lo tanto si podemos aproximar con este método sus ceros obtendremos la raíz que estábamos buscando.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a>S <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">100</span>)</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="kw">def</span> f(x, S<span class="op">=</span><span class="dv">2</span>):</span>
<span id="cb1-8"><a href="#cb1-8"></a>    <span class="cf">return</span> x<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> S</span>
<span id="cb1-9"><a href="#cb1-9"></a></span>
<span id="cb1-10"><a href="#cb1-10"></a>plt.plot(x, f(x))</span>
<span id="cb1-11"><a href="#cb1-11"></a>plt.grid()</span>
<span id="cb1-12"><a href="#cb1-12"></a>ax <span class="op">=</span> plt.gca()</span>
<span id="cb1-13"><a href="#cb1-13"></a>ax.spines[<span class="st">&#39;right&#39;</span>].set_color(<span class="st">&#39;none&#39;</span>)</span>
<span id="cb1-14"><a href="#cb1-14"></a>ax.spines[<span class="st">&#39;top&#39;</span>].set_color(<span class="st">&#39;none&#39;</span>)</span>
<span id="cb1-15"><a href="#cb1-15"></a>ax.xaxis.set_ticks_position(<span class="st">&#39;bottom&#39;</span>)</span>
<span id="cb1-16"><a href="#cb1-16"></a>ax.spines[<span class="st">&#39;bottom&#39;</span>].set_position((<span class="st">&#39;data&#39;</span>,<span class="dv">0</span>))</span>
<span id="cb1-17"><a href="#cb1-17"></a>ax.yaxis.set_ticks_position(<span class="st">&#39;left&#39;</span>)</span>
<span id="cb1-18"><a href="#cb1-18"></a>ax.spines[<span class="st">&#39;left&#39;</span>].set_position((<span class="st">&#39;data&#39;</span>,<span class="dv">0</span>))</span>
<span id="cb1-19"><a href="#cb1-19"></a>plt.show()</span></code></pre></div>
<figure>
<img src="/assets/posts/metodo-babilonico/output_1_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<p>El primer paso es partir de un valor inicial <span class="math inline">\(x_0\)</span>. Luego podemos aproximar la función en este punto con su linea tangente. Usando la derivada sabemos que la recta tangente a este punto es</p>
<p><span class="math display">\[ f(x) \approx f&#39;(x_0)(x - x_0) + f(x_0) \]</span></p>
<p>Luego podemos encontrar una nueva aproximación para el cero despejando <span class="math inline">\(x\)</span> de la función aproximada.</p>
<p><span class="math display">\[x_1 = x_0 - f(x_0)/f&#39;(x_0)\]</span></p>
<p>Finalmente remplazando con la función <span class="math inline">\(f(x)=x^2 - S\)</span> encontramos que luego de <span class="math inline">\(k\)</span> iteraciones una aproximación para la raíz de <span class="math inline">\(S\)</span> esta dada por las siguientes ecuaciones (¿puedes ver porque?)</p>
<p><span class="math display">\[x_{k} = \frac{S+x_{k-1}^2}{2x_{k-1}}\]</span></p>
<p><span class="math display">\[\sqrt{S} =  \lim_{k \rightarrow \infty}x_k\]</span></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">def</span> f_prime(x):</span>
<span id="cb2-2"><a href="#cb2-2"></a>    <span class="cf">return</span> <span class="dv">2</span><span class="op">*</span>x</span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a>x0 <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>plt.scatter([x0], [f(x0)], <span class="dv">50</span>)</span>
<span id="cb2-6"><a href="#cb2-6"></a>plt.plot(x, f(x))</span>
<span id="cb2-7"><a href="#cb2-7"></a>plt.plot(x, f_prime(x0)<span class="op">*</span>(x <span class="op">-</span> x0) <span class="op">+</span> f(x0))</span>
<span id="cb2-8"><a href="#cb2-8"></a>plt.grid()</span>
<span id="cb2-9"><a href="#cb2-9"></a>ax <span class="op">=</span> plt.gca()</span>
<span id="cb2-10"><a href="#cb2-10"></a>ax.spines[<span class="st">&#39;right&#39;</span>].set_color(<span class="st">&#39;none&#39;</span>)</span>
<span id="cb2-11"><a href="#cb2-11"></a>ax.spines[<span class="st">&#39;top&#39;</span>].set_color(<span class="st">&#39;none&#39;</span>)</span>
<span id="cb2-12"><a href="#cb2-12"></a>ax.xaxis.set_ticks_position(<span class="st">&#39;bottom&#39;</span>)</span>
<span id="cb2-13"><a href="#cb2-13"></a>ax.spines[<span class="st">&#39;bottom&#39;</span>].set_position((<span class="st">&#39;data&#39;</span>,<span class="dv">0</span>))</span>
<span id="cb2-14"><a href="#cb2-14"></a>ax.yaxis.set_ticks_position(<span class="st">&#39;left&#39;</span>)</span>
<span id="cb2-15"><a href="#cb2-15"></a>ax.spines[<span class="st">&#39;left&#39;</span>].set_position((<span class="st">&#39;data&#39;</span>,<span class="dv">0</span>))</span>
<span id="cb2-16"><a href="#cb2-16"></a>plt.show()</span></code></pre></div>
<figure>
<img src="/assets/posts/metodo-babilonico/output_3_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<h2 id="implementación-en-python">Implementación en Python</h2>
<p>Si buscamos la raíz cuadrada de <span class="math inline">\(2\)</span> podemos partir con <span class="math inline">\(x_0=2\)</span> y usando las ecuaciones que encontramos en la sección anterior buscar una aproximación cada vez mas cercana al valor real.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a>S <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>x0 <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>x_n <span class="op">=</span> [x0] <span class="co"># guardaremos la aprroximacion de cada iteracion</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb3-5"><a href="#cb3-5"></a>    x_prev <span class="op">=</span> x_n[<span class="op">-</span><span class="dv">1</span>] <span class="co"># el ultimo elemento de la lista</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>    x_next <span class="op">=</span> (S <span class="op">+</span> x_prev<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> (<span class="dv">2</span><span class="op">*</span>x_prev)</span>
<span id="cb3-7"><a href="#cb3-7"></a>    x_n.append(x_next)</span>
<span id="cb3-8"><a href="#cb3-8"></a></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="bu">print</span>(x_n)</span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="bu">print</span>(x_n[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="bu">print</span>(<span class="ss">f&quot;Error: </span><span class="sc">{</span>x_n[<span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> <span class="sc">np.</span>sqrt(S)<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="bu">print</span>(np.sqrt(<span class="dv">2</span>))</span></code></pre></div>
<pre><code>[2, 1.5, 1.4166666666666667, 1.4142156862745099]
1.4142156862745099
Error: 2.1239014147411694e-06
1.4142135623730951</code></pre>
<p>¡Listo! Ya con solo 3 iteraciones ya podemos encontrar la raíz correcta a 5 decimales, y si tan solo iteramos dos veces más ya tenemos la respuesta a 12 decimales.</p>
<p>Un parámetro importante para el método de Newton es el punto de partida <span class="math inline">\(x_0\)</span>. Prueba con distintos valores y observa que para un numero pequeño de iteraciones el algoritmo no es capaz de llegar a la respuesta si el punto de partida es muy lejano al real.</p>
<p>Las calculadoras y computadores implementan aproximaciones para poder garantizar una rápida convergencia. Por ahora solo implementaremos parámetros extras que controlan el numero de iteraciones y la precisión de la respuesta. Lo que hacemos es iterar todas las veces que sea necesario hasta que la distancia entre la aproximación actual y la respuesta correcta sea menor a un numero pequeño <code>epsilon</code>. Por otro lado independiente de la calidad de la aproximación no haremos más de <code>maxiter</code> iteraciones.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">def</span> sqrt(S, x0<span class="op">=</span><span class="va">None</span>, maxiter<span class="op">=</span><span class="dv">100</span>, epsilon<span class="op">=</span><span class="fl">1e-6</span>):</span>
<span id="cb5-2"><a href="#cb5-2"></a>    <span class="cf">if</span> x0 <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb5-3"><a href="#cb5-3"></a>        x0 <span class="op">=</span> S</span>
<span id="cb5-4"><a href="#cb5-4"></a>    i<span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>    <span class="cf">while</span> <span class="bu">abs</span>(x0<span class="op">**</span><span class="dv">2</span><span class="op">-</span>S) <span class="op">&gt;</span> epsilon <span class="kw">and</span> i <span class="op">&lt;</span> maxiter:</span>
<span id="cb5-6"><a href="#cb5-6"></a>        x0 <span class="op">=</span> (S <span class="op">+</span> x0<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> (<span class="dv">2</span><span class="op">*</span>x0)</span>
<span id="cb5-7"><a href="#cb5-7"></a>        i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>    <span class="cf">return</span> x0</span>
<span id="cb5-9"><a href="#cb5-9"></a></span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="bu">print</span>(sqrt(<span class="dv">2</span>))</span></code></pre></div>
<pre><code>1.4142135623746899</code></pre>
<p>En este articulo aprendimos como deducir el metodo Babilónico para encontrar raíces cuadradas. El metodo de Newton-Rapson utilizado se puede aplicar para encontrar las soluciones de una gran cantidad de ecuaciones usadas en la practica incluyendo aplicaciones en optimización. Puedes descargar este articulo como un cuaderno de Jupyter <a href="/assets/posts/metodo-babilonico/Metodo-de-Babilonia-para-calcular-raices-cuadradas.ipynb">aquí</a></p>

        </article>

        <footer>
            <div class="footer-container">
                <div class="footer-colm">
                    <a href=https://tito21.github.io>Alberto Di Biase</a>
                    <ul>
                                                    <li><a href=about.html>About</a></li>
                                                    <li><a href=categories.html>Categories</a></li>
                                            </ul>
                </div>
                <div class="footer-colm">
                    Redes Sociales:
                    <ul>
                                                    <li><a href=https://github.com/tito21/>github</a></li>
                                                    <li><a href=https://www.reddit.com/user/AlbertoDiBiase>reddit</a></li>
                                            </ul>
                </div>
                <div class="footer-colm" style="text-align: left;">
                    <p>Estudiante de Ingeniería Biomédica en la Pontificia Universidad Católica de Chile (UC). Mis pasiones son programar, los numeros y la enseñanza.</p>
                </div>
            </div>
        </footer>
        <div class="close-message">
            <p>Todo el contenido de esta pagina esta bajo la Licencia <a
            href="http://creativecommons.org/licenses/by-sa/4.0/">CC-by-sa</a> y
            el código bajo la licencia <a
            href="https://choosealicense.com/licenses/mit/">MIT</a></p>

                <p>Sitio alojado en <a href="github.com">GitHub</a> y producido
                con YASSG</p>
        </div>
    </body>

</html>